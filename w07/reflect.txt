///////////////////////////////////////////////////////////////////////////
                               Reflection
                             Workshop - #7
Full Name  : SAHIL HARESHBHAI PATEL
Student ID#: 173793225

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
///////////////////////////////////////////////////////////////////////////

ANSWER 1:

1. Impact of Not Using Structures

a) Structure Definitions:

struct PlayerInfo
{
    char character;
    int lives;
    int treasures;
    int pastPositions[MAX_PATH];
};

struct GameInfo
{
    int moves;
    int pathLength;
    int bombPosition[MAX_PATH];
    int treasurePosition[MAX_PATH];
};


b) variable declarations

struct PlayerInfo player1;
struct GameInfo game;

New code with out using structures

Whereas in its absence, you would need to declare and sort several separate variables yourself.


char player1_character;
int player1_lives;
int player1_treasures;
int player1_pastPositions[MAX_PATH];

int game_moves;
int game_pathLength;
int game_bombPosition[MAX_PATH];
int game_treasurePosition[MAX_PATH];


And for the rest of the code you would have to make similar changes. For example, replacing player1. character with player1_character, player1. belongs to player1_class, has player1_lives, and so on.

Answer 2 

Parallel Arrays used in the code:

game.bombPosition[MAX_PATH] and game.treasurePosition[MAX_PATH]
player1.pastPositions[MAX_PATH]

Relationship and Contribution:

game.bombPosition and game.treasurePosition are used to store the positions of bombs and treasures, respectively, along the path.
player1.pastPositions is used to keep track of the positions the player has already visited.

These arrays help in solving the problem in order to make the game be in a position to locate positions of bombs, treasures and the movements made. This comes in handy in explaining a state in a game that pertains to the player, touching a bomb, getting a treasure, or getting to a certain position for the second time, for instance. 
 
Answer 3:

Deepest Nested Statement:
The deepest nested statement is inside the do-while loop for managing the game moves and updating the game state. Here's the relevant portion:

if (game.bombPosition[movedPosition - 1] == 1 && game.treasurePosition[movedPosition - 1] == 1)
{
    printf("===============> [&] !!! BOOOOOM !!! [&]\n");
    printf("===============> [&] $$$ Life Insurance Payout!!! [&]\n");
    player1.treasures++;
    player1.lives--;
}
else if (game.bombPosition[movedPosition - 1] == 1)
{
    printf("===============> [!] !!! BOOOOOM !!! [!]\n");
    player1.lives--;
}
else if (game.treasurePosition[movedPosition - 1] == 1)
{
    printf("===============> [$] $$$ Found Treasure! $$$ [$]\n");
    player1.treasures++;
}
else
{
    printf("===============> [.] ...Nothing found here... [.]\n");
}


Explanation: 
 
 The code then recalls the current position of the player to see if there is a bomb, treasure, both or there is none at all. 
 According to the condition, it modifies the player lives and treasures if any. 
 Such a loop goes on until the game ends (when player loses all the lives or moves out of the board). 
 Such nested logic is vital because it defines the actions of the player with the game setting up to a certain level. 
 
 This way, when looking at structures and parallel arrays as methods of maintaining complicated data in the most concise and manageable way possible, it is easier to comprehend the processes based on these notions in the given code.

